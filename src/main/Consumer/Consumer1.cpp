#include "Board.h"
#include "SocketClient.h"
#include "Consumer1.h"
#include <math.h>
#include <utility>
#include <opencv2/opencv.hpp>


using namespace cv;

//.......... 필요한 객체들 생성
Board board = Board();  
SocketClient client = SocketClient();
vector<pair<String, Rect>> matching_result;  // 영역과 이름을 매칭한 함수 


void* Consumer1::consumer_doing(const Mat& frame) {
    
    // .......1 식판의 영역을 구한다.
    // 중심 check , 식판의 위치가 휘어지면 
    board_obj b_o= board.get_target_area(frame);  //이미지와 중심이 들어있는 구조체 반환
    board.crnt_point = b_o.board_center; // 식판의 중심좌표 update
    if (abs(board.pre_point.x - board.crnt_point.x) > 25 || abs(board.pre_point.y - board.crnt_point.y) > 25) {
        Mat board_img = b_o.board_img;
        
        // .......2 식판 내의 음식 영역
        frgm_obj f_o = board.frgm_board(board_img); // 이미지와영역벡터가 도출
        
        vector<Mat> frgm_imgs = f_o.crop_imgs;
        vector<Rect> frgm_Rects = f_o.crop_Rects;

         for (int i = 0; i < frgm_imgs.size(); i++) { // 소켓을 통해 이미지를 전송한다.
            client.sendImage(frgm_imgs[i]);
        }

        // .......3 소켓으로부터 답변을 전송 받는다.
         vector<string> result;
        while (1) {
            result = client.recv(); // 값이 들어오길 기다린다.
            if (result.size() != 0) break;
        }

        //matching_result를 초기화 시키고 데이터를 담는다.
        matching_result.clear();
        for (int i = 0; i < frgm_Rects.size(); i++) { // 소켓을 통해 받은 결과와 이미지의 이름을 매칭.
            matching_result.push_back({result[i],frgm_Rects[i]});
        }

    
    }
    //########## 받은 이미지를 이용하여 #############
    pre_point = board_obj.board_center; // 현재의 식판의 중심좌표룰 과거로update

   

    
    


}